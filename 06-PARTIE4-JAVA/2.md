## Exercice 1 — Couplage fort

**Mauvaise pratique (à corriger vers interface + injection)**

```java
class MySQLDatabase {
    void save(String data) { System.out.println("MySQL: " + data); }
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase(); // couplage fort

    void register(String user) {
        db.save(user);
    }

    public static void main(String[] args) {
        new UserService().register("alice");
    }
}
```

**À faire :** créer `interface Database`, implémentation `MySQLDatabase`, puis injecter `Database` via le constructeur de `UserService`.

---

## Exercice 2 — SRP (trop de responsabilités)

**Mauvaise pratique (à découper en 3 classes)**

```java
class Report {
    void generate() { System.out.println("gen"); }
    void saveToFile() { System.out.println("save"); }
    void sendByEmail() { System.out.println("email"); }

    public static void main(String[] args) {
        Report r = new Report();
        r.generate();
        r.saveToFile();
        r.sendByEmail();
    }
}
```

**À faire :** créer `ReportGenerator`, `ReportSaver`, `ReportSender`. La méthode `main` orchestre les trois.

---

## Exercice 3 — OCP (if/else sur le type)

**Mauvaise pratique (à transformer en polymorphisme)**

```java
class Payment {
    void pay(String method) {
        if ("credit".equals(method)) {
            System.out.println("Carte");
        } else if ("paypal".equals(method)) {
            System.out.println("PayPal");
        } else if ("cash".equals(method)) {
            System.out.println("Espèces");
        } else {
            throw new IllegalArgumentException("inconnu");
        }
    }

    public static void main(String[] args) {
        new Payment().pay("credit");
    }
}
```

**À faire :** créer `interface PaymentMethod { void pay(); }`, implémentations (`CreditCardPayment`, `PayPalPayment`, …) et un `PaymentProcessor` qui reçoit un `PaymentMethod`.

---

## Exercice 4 — LSP (contrat cassé)

**Mauvaise pratique (à corriger vers un contrat commun cohérent)**

```java
class Bird {
    void fly() { System.out.println("vole"); }
}

class Penguin extends Bird {
    @Override
    void fly() { throw new UnsupportedOperationException(); } // casse le contrat
}

public class Main {
    public static void main(String[] args) {
        Bird b1 = new Bird();
        Bird b2 = new Penguin();
        b1.fly();
        b2.fly(); // crash
    }
}
```

**À faire :** remplacer par `interface Bird { void move(); }`, puis `Sparrow.move()` → “vole”, `Penguin.move()` → “nage”. Le `main` ne doit plus planter.

---

## Exercice 5 — DIP (dépendance aux détails)

**Mauvaise pratique (à inverser vers abstraction)**

```java
class LightBulb {
    void turnOn() { System.out.println("On"); }
}

class Switch {
    private LightBulb bulb = new LightBulb(); // dépendance concrète

    void operate() { bulb.turnOn(); }

    public static void main(String[] args) {
        new Switch().operate();
    }
}
```

**À faire :** créer `interface Switchable { void turnOn(); }`, faire implémenter `LightBulb`, modifier `Switch` pour recevoir un `Switchable` par constructeur. Ajouter `Fan` sans toucher `Switch`.


# Annexe – Modélisation Objet et Principes SOLID

## Objectif du cours

Apprendre à concevoir des modèles objets en Java en appliquant les **principes SOLID**, afin de créer du code modulaire, extensible, et testable.



## 1. Couplage faible et couplage fort

### Exemple Java

```java
// Couplage fort : dépendance directe
class MySQLDatabase {
    public void save(String data) {
        System.out.println("Saving to MySQL: " + data);
    }
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase(); // dépendance forte
    public void register(String user) {
        db.save(user);
    }
}
```

```java
// Couplage faible : dépendance à une abstraction
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) { System.out.println("Saving to MySQL: " + data); }
}

class UserService {
    private Database db;
    public UserService(Database db) { this.db = db; } // injection
    public void register(String user) { db.save(user); }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class UserService {
        - MySQLDatabase db
        + register(user)
    }
    class MySQLDatabase {
        + save(data)
    }
    UserService --> MySQLDatabase
```

```mermaid
classDiagram
    class UserService {
        - Database db
        + register(user)
    }
    class Database {
        <<interface>>
        + save(data)
    }
    class MySQLDatabase {
        + save(data)
    }
    UserService --> Database
    MySQLDatabase ..|> Database
```



## 2. Principe de Responsabilité Unique (SRP)

### Exemple Java

```java
// Mauvais : une seule classe fait trop de choses
class Report {
    void generateReport() {}
    void saveToFile() {}
    void sendByEmail() {}
}
```

```java
// Bon : séparation des responsabilités
class ReportGenerator { void generate() {} }
class ReportSaver { void save() {} }
class ReportSender { void send() {} }
```

### Diagramme Mermaid

```mermaid
classDiagram
    class ReportGenerator { + generate() }
    class ReportSaver { + save() }
    class ReportSender { + send() }
```



## 3. Principe Ouvert/Fermé (OCP)

### Exemple Java

```java
// Mauvais : modification obligatoire
class Payment {
    void pay(String method) {
        if (method.equals("credit")) { /* ... */ }
        else if (method.equals("paypal")) { /* ... */ }
    }
}
```

```java
// Bon : extension via interface
interface PaymentMethod { void pay(); }

class CreditCardPayment implements PaymentMethod {
    public void pay() { System.out.println("Paiement carte"); }
}

class PayPalPayment implements PaymentMethod {
    public void pay() { System.out.println("Paiement PayPal"); }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class PaymentMethod {
        <<interface>>
        + pay()
    }
    class CreditCardPayment {
        + pay()
    }
    class PayPalPayment {
        + pay()
    }
    CreditCardPayment ..|> PaymentMethod
    PayPalPayment ..|> PaymentMethod
```



## 4. Composition vs Héritage

### Exemple Java

```java
// Mauvais : héritage
class Engine {}
class Car extends Engine {} // une voiture n'est pas un moteur
```

```java
// Bon : composition
class Engine {}
class Car {
    private Engine engine;
    public Car(Engine engine) { this.engine = engine; }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class Engine {
        + start()
    }
    class Car {
        - Engine engine
        + drive()
    }
    Car --> Engine : "has-a"
```


## 5. Dépendance aux Interfaces

### Exemple Java

```java
// Mauvais
class OrderService {
    private MySQLDatabase db = new MySQLDatabase();
}
```

```java
// Bon
class OrderService {
    private Database db;
    public OrderService(Database db) { this.db = db; }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class OrderService {
        - Database db
    }
    class Database {
        <<interface>>
    }
    class MySQLDatabase {
        + save()
    }
    MySQLDatabase ..|> Database
    OrderService --> Database
```



## 6. Principe de Substitution de Liskov (LSP)

### Exemple Java

```java
// Violation
class Bird {
    void fly() {}
}

class Penguin extends Bird {
    void fly() { throw new UnsupportedOperationException(); }
}
```

```java
// Correction
interface Bird { void move(); }

class Sparrow implements Bird {
    public void move() { System.out.println("Le moineau vole"); }
}

class Penguin implements Bird {
    public void move() { System.out.println("Le pingouin nage"); }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class Bird {
        <<interface>>
        + move()
    }
    class Sparrow {
        + move()
    }
    class Penguin {
        + move()
    }
    Sparrow ..|> Bird
    Penguin ..|> Bird
```



## 7. Principe d’Inversion de Dépendance (DIP)

### Exemple Java

```java
// Violation
class LightBulb {
    void turnOn() { System.out.println("On"); }
}

class Switch {
    private LightBulb bulb = new LightBulb();
    void operate() { bulb.turnOn(); }
}
```

```java
// Respect
interface Switchable { void turnOn(); }

class LightBulb implements Switchable {
    public void turnOn() { System.out.println("On"); }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) { this.device = device; }
    void operate() { device.turnOn(); }
}
```

### Diagramme Mermaid

```mermaid
classDiagram
    class Switchable {
        <<interface>>
        + turnOn()
    }
    class LightBulb {
        + turnOn()
    }
    class Switch {
        - Switchable device
        + operate()
    }
    LightBulb ..|> Switchable
    Switch --> Switchable
```



## Conclusion

* Les principes **SOLID** permettent d’obtenir du code clair, extensible et testable.
* La **composition** doit être privilégiée sur l’héritage.
* Il est essentiel de programmer contre des **interfaces** et non contre des implémentations concrètes.

