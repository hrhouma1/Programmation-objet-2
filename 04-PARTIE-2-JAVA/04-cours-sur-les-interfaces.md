# ğŸ“˜ Cours Exhaustif sur les Interfaces en Java

## 1. Introduction

Une **interface** en Java dÃ©finit un **contrat** : un ensemble de mÃ©thodes (et Ã©ventuellement de constantes, mÃ©thodes par dÃ©faut, mÃ©thodes statiques) que les classes implÃ©mentant lâ€™interface doivent respecter.

* **Classe** = dÃ©finit des donnÃ©es et comportements.
* **Interface** = dÃ©finit uniquement des **capacitÃ©s**, sans implÃ©mentation complÃ¨te (sauf `default`/`static` depuis Java 8, `private` depuis Java 9).

ğŸ‘‰ Une interface **ne peut pas Ãªtre instanciÃ©e directement**.
ğŸ‘‰ Une classe peut **implÃ©menter plusieurs interfaces** (Java gÃ¨re lâ€™hÃ©ritage multiple dâ€™interfaces).

<br/>
<br/>

## 2. DÃ©claration dâ€™une interface

```java
public interface Vehicule {
    void demarrer();   // mÃ©thode abstraite implicite
    void arreter();    // mÃ©thode abstraite implicite
}
```

* Toutes les mÃ©thodes **sans corps** sont automatiquement :

  * `public`
  * `abstract`
* Toute variable dÃ©finie dans une interface est :

  * `public`
  * `static`
  * `final`

<br/>
<br/>

## 3. ImplÃ©mentation dâ€™une interface

```java
public class Voiture implements Vehicule {
    @Override
    public void demarrer() {
        System.out.println("La voiture dÃ©marre.");
    }

    @Override
    public void arreter() {
        System.out.println("La voiture s'arrÃªte.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Vehicule v = new Voiture(); // polymorphisme
        v.demarrer();
        v.arreter();
    }
}
```

ğŸ“Œ **Sortie attendue**

```
La voiture dÃ©marre.
La voiture s'arrÃªte.
```

<br/>
<br/>

## 4. Constantes dans une interface

```java
public interface Constantes {
    int VITESSE_MAX = 120; // public static final implicite
}
```

```java
public class Moto implements Vehicule, Constantes {
    @Override
    public void demarrer() {
        System.out.println("Moto dÃ©marre avec vitesse max " + VITESSE_MAX);
    }

    @Override
    public void arreter() {
        System.out.println("Moto arrÃªtÃ©e.");
    }
}
```

ğŸ“Œ **Sortie**

```
Moto dÃ©marre avec vitesse max 120
Moto arrÃªtÃ©e.
```

<br/>
<br/>

## 5. MÃ©thodes par dÃ©faut (`default`) â€“ Java 8+

Permet de donner une implÃ©mentation **par dÃ©faut**.

```java
public interface Vehicule {
    void demarrer();
    void arreter();

    default void klaxonner() {
        System.out.println("Bip bip !");
    }
}
```

```java
public class Bus implements Vehicule {
    @Override
    public void demarrer() { System.out.println("Bus dÃ©marre."); }
    @Override
    public void arreter() { System.out.println("Bus arrÃªtÃ©."); }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Vehicule b = new Bus();
        b.demarrer();
        b.klaxonner(); // mÃ©thode hÃ©ritÃ©e sans rÃ©Ã©criture obligatoire
    }
}
```

ğŸ“Œ **Sortie**

```
Bus dÃ©marre.
Bip bip !
```

<br/>
<br/>

## 6. MÃ©thodes statiques dans les interfaces

```java
public interface MathUtil {
    static int carre(int x) {
        return x * x;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        int res = MathUtil.carre(5); // Appel direct via lâ€™interface
        System.out.println(res);
    }
}
```

ğŸ“Œ **Sortie**

```
25
```

<br/>
<br/>

## 7. MÃ©thodes privÃ©es dans les interfaces (Java 9+)

Utile pour factoriser du code commun aux `default` et `static`.

```java
public interface Logger {
    private void log(String msg) {
        System.out.println("[LOG] " + msg);
    }

    default void info(String msg) {
        log("INFO: " + msg);
    }

    default void error(String msg) {
        log("ERROR: " + msg);
    }
}
```

<br/>
<br/>

## 8. HÃ©ritage multiple avec interfaces

Une classe peut implÃ©menter plusieurs interfaces :

```java
interface Volant { void voler(); }
interface Nageant { void nager(); }

public class Canard implements Volant, Nageant {
    @Override
    public void voler() { System.out.println("Le canard vole."); }
    @Override
    public void nager() { System.out.println("Le canard nage."); }
}
```

ğŸ“Œ Sortie

```
Le canard vole.
Le canard nage.
```

<br/>
<br/>

## 9. Conflit de mÃ©thodes par dÃ©faut

Si deux interfaces dÃ©finissent une mÃ©thode `default` identique â†’ **la classe doit rÃ©soudre le conflit**.

```java
interface A {
    default void saluer() { System.out.println("Bonjour de A"); }
}
interface B {
    default void saluer() { System.out.println("Bonjour de B"); }
}

public class C implements A, B {
    @Override
    public void saluer() {
        A.super.saluer(); // rÃ©solution explicite
        B.super.saluer();
    }
}
```

ğŸ“Œ Sortie

```
Bonjour de A
Bonjour de B
```

<br/>
<br/>

## 10. Interfaces fonctionnelles & Lambdas (Java 8+)

Une interface avec **une seule mÃ©thode abstraite** = *fonctionnelle* â†’ utilisable avec les lambdas.

```java
@FunctionalInterface
interface Calculateur {
    int operation(int a, int b);
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculateur addition = (x, y) -> x + y;
        Calculateur multiplication = (x, y) -> x * y;

        System.out.println(addition.operation(3, 5));      // 8
        System.out.println(multiplication.operation(3, 5)); // 15
    }
}
```

<br/>
<br/>

## 11. Interfaces vs Classes Abstraites

| CaractÃ©ristique   | Interface                                  | Classe Abstraite                               |
| ----------------- | ------------------------------------------ | ---------------------------------------------- |
| HÃ©ritage multiple | âœ” (plusieurs interfaces)                   | âœ˜ (une seule superclasse)                      |
| Constructeurs     | âœ˜                                          | âœ”                                              |
| Variables         | `public static final` uniquement           | Tous types                                     |
| MÃ©thodes          | Abstraites, `default`, `static`, `private` | Abstraites et concrÃ¨tes                        |
| Objectif          | DÃ©finir un contrat                         | DÃ©finir un comportement partiel et Ã©tat commun |

<br/>
<br/>

## 12. Exemples avancÃ©s

### Interface pour un plugin systÃ¨me

```java
public interface Plugin {
    String getNom();
    void executer();
}
```

```java
public class PluginImpression implements Plugin {
    public String getNom() { return "Impression"; }
    public void executer() { System.out.println("Impression en cours..."); }
}
```

<br/>
<br/>

## 13. Exercices pratiques

### Exercice 1

CrÃ©er une interface `Animal` avec `manger()` et `dormir()`. ImplÃ©menter `Chat` et `Chien`.

âœ… Attendu : comprendre `implements` et polymorphisme.

<br/>
<br/>

### Exercice 2

CrÃ©er deux interfaces `Volant` et `Marin`. CrÃ©er une classe `Hydravion` qui implÃ©mente les deux.

âœ… Attendu : hÃ©ritage multiple.

<br/>
<br/>

### Exercice 3

CrÃ©er une interface `Operation` fonctionnelle. Tester des lambdas pour addition, soustraction, multiplication.

âœ… Attendu : comprendre les **interfaces fonctionnelles**.

<br/>
<br/>

### Exercice 4

CrÃ©er deux interfaces avec la mÃªme mÃ©thode `default`. ImplÃ©menter une classe qui rÃ©sout le conflit.

âœ… Attendu : maÃ®trise des `super` spÃ©cifiques (`A.super.methode()`).

<br/>
<br/>

## 14. Commandes pour tester

* Compilation (Linux/macOS) :

```bash
javac -d out $(find src -name "*.java")
java -cp out Main
```

* Compilation (Windows PowerShell) :

```powershell
$files = Get-ChildItem -Recurse src -Filter *.java | % { $_.FullName }
javac -d out $files
java -cp out Main
```

<br/>
<br/>

## 15. Points clÃ©s Ã  retenir

1. **Interface = contrat**.
2. Une classe peut **implÃ©menter plusieurs interfaces**.
3. MÃ©thodes : `abstract` (par dÃ©faut), `default`, `static`, `private`.
4. Variables : toujours `public static final`.
5. Conflits â†’ rÃ©solus via `Interface.super.methode()`.
6. Interfaces fonctionnelles = base des **lambdas** et **API Streams**.

